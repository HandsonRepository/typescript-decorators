## メソッド・デコレータ

以下を参考に実装した

- [もう怖くないTypeScriptのDecorator機能](https://zenn.dev/miruoon_892/articles/365675fa5343ed)
  - [Method Decorators: メソッド・デコレータ](https://zenn.dev/miruoon_892/articles/365675fa5343ed#method-decorators%3A-%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%83%BB%E3%83%87%E3%82%B3%E3%83%AC%E3%83%BC%E3%82%BF)


チェスの駒は規則正しく前後・左右・斜めに動くものと、そうでないものがある
ほとんどが前者の駒で、今回はこのケースのみを考えた

攻撃する時（敵のコマを取るとき）は通常の移動とは違うマス目に移動できたり、
移動時も間に別のコマがあったら通れなかったり、
今いる位置が盤の端だったら移動可能な方向があっても移動の余地がなかったり、
そもそもポーンみたいに盤の端から端まで移動できるわけじゃない(1マスしか進めない)コマがあったり、
...

プロダクトのレベルだと色々考慮すべきことはあるけど話がややこしくなるので今回はデコレータで移動方向を返すだけにする

```
$ npx ts-node method-decorators.ts
Rook can move to Set(4) { '←', '↑', '→', '↓' }
Bishop can move to Set(4) { '↖', '↗', '↘', '↙' }
Queen can move to Set(8) { '←', '↑', '→', '↓', '↖', '↗', '↘', '↙' }
```

被修飾メソッドの方で便宜上空の `Set` を返しているのがダサい

```
class Rook implements Piece {
  @addMovableDirections('←', '↑', '→', '↓')
  movableDirections() {
    return new Set([]);
  }
}
```

今回だといちいちデコレータでやらなくてもプロパティで方向持っておいてそれを使う方式にした方がいいと思うがここは書き捨てる
ナイトみたいな不規則な動きのコマと分けやすいという実益はあるが、一旦深掘りはやめる
